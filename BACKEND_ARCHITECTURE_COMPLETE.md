# ğŸ—ï¸ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù„Ù…Ø´Ø±ÙˆØ¹ AuditOrbit

## ğŸ“‹ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙŠØ§Øª
1. [Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø©](#Ù†Ø¸Ø±Ø©-Ø¹Ø§Ù…Ø©)
2. [Ø§Ù„Ù…ÙƒØ¯Ø³ Ø§Ù„ØªÙ‚Ù†ÙŠ Ø§Ù„Ù…ÙˆØµÙ‰ Ø¨Ù‡](#Ø§Ù„Ù…ÙƒØ¯Ø³-Ø§Ù„ØªÙ‚Ù†ÙŠ)
3. [Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹](#Ù‡ÙŠÙƒÙ„-Ø§Ù„Ù…Ø´Ø±ÙˆØ¹)
4. [Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª](#Ù‚Ø§Ø¹Ø¯Ø©-Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª)
5. [Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø© ÙˆØ§Ù„ØªÙÙˆÙŠØ¶](#Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©-ÙˆØ§Ù„ØªÙÙˆÙŠØ¶)
6. [ÙˆØ§Ø¬Ù‡Ø§Øª Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª (APIs)](#ÙˆØ§Ø¬Ù‡Ø§Øª-Ø¨Ø±Ù…Ø¬Ø©-Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª)
7. [Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù„ÙØ§Øª](#Ø¥Ø¯Ø§Ø±Ø©-Ø§Ù„Ù…Ù„ÙØ§Øª)
8. [Ø§Ù„Ø£Ù…Ø§Ù†](#Ø§Ù„Ø£Ù…Ø§Ù†)
9. [Ø§Ù„ØªØ«Ø¨ÙŠØª ÙˆØ§Ù„Ø¥Ø¹Ø¯Ø§Ø¯](#Ø§Ù„ØªØ«Ø¨ÙŠØª-ÙˆØ§Ù„Ø¥Ø¹Ø¯Ø§Ø¯)
10. [Ø§Ù„Ù†Ø´Ø±](#Ø§Ù„Ù†Ø´Ø±)

---

## ğŸ¯ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø©

Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¯Ø±Ø§Ø³Ø© Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ù…Ø´Ø±ÙˆØ¹ØŒ Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠ Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ù„Ù€ Backend Ø§Ù„Ø°ÙŠ ÙŠØ¯Ø¹Ù… Ø¬Ù…ÙŠØ¹ Ù…ÙŠØ²Ø§Øª AuditOrbit:

### Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø¯Ø¹Ù…Ù‡Ø§:
- âœ… Ù†Ø¸Ø§Ù… Ù…ØµØ§Ø¯Ù‚Ø© ÙˆØªÙÙˆÙŠØ¶ Ù…ØªÙ‚Ø¯Ù… (JWT + Refresh Tokens)
- âœ… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ø£Ø¯ÙˆØ§Ø± ÙˆØ§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
- âœ… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø®Ø·Ø· Ø§Ù„Ø³Ù†ÙˆÙŠØ© (Annual Plans)
- âœ… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ÙŠØ© (Engagements)
- âœ… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø¯Ù„Ø© ÙˆØ§Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª (Evidence)
- âœ… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙˆØ§Ù„ØªÙˆØµÙŠØ§Øª (Findings)
- âœ… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± (Reports)
- âœ… Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø¹Ù…Ù„ (Working Papers)
- âœ… Ø§Ù„Ø¹ÙŠÙ†Ø§Øª (Samples)
- âœ… Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© (Follow-ups)
- âœ… Ø±Ø¯ÙˆØ¯ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© (Management Responses)
- âœ… Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„ØªØ­Ù‚Ù‚ (Checklists)
- âœ… Ø±ÙØ¹ ÙˆØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ù„ÙØ§Øª
- âœ… Ø³Ø¬Ù„Ø§Øª Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ (Audit Logs)
- âœ… Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙØ¹Ù„ÙŠ

---

## ğŸ› ï¸ Ø§Ù„Ù…ÙƒØ¯Ø³ Ø§Ù„ØªÙ‚Ù†ÙŠ Ø§Ù„Ù…ÙˆØµÙ‰ Ø¨Ù‡

### Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø£ÙˆÙ„: FastAPI + PostgreSQL (Ù…ÙˆØµÙ‰ Ø¨Ù‡ Ø¨Ø´Ø¯Ø©)

**Ù„Ù…Ø§Ø°Ø§ FastAPIØŸ**
- âš¡ Ø£Ø¯Ø§Ø¡ Ø¹Ø§Ù„ÙŠ Ø¬Ø¯Ø§Ù‹ (Ø£Ø³Ø±Ø¹ Ù…Ù† Django Ùˆ Flask)
- ğŸ“ ØªÙˆØ«ÙŠÙ‚ ØªÙ„Ù‚Ø§Ø¦ÙŠ (Swagger UI + ReDoc)
- ğŸ”’ Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù„Ù€ Type Hints ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
- ğŸš€ Ø³Ù‡ÙˆÙ„Ø© Ø§Ù„ØªØ·ÙˆÙŠØ± ÙˆØ§Ù„ØµÙŠØ§Ù†Ø©
- ğŸ”„ Ø¯Ø¹Ù… Async/Await Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…ØªØ²Ø§Ù…Ù†Ø©
- ğŸ¯ Ù…Ø«Ø§Ù„ÙŠ Ù„Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„Ø­Ø¯ÙŠØ«Ø©

**Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª:**
\`\`\`
Backend:
- FastAPI 0.109+ (Web Framework)
- SQLAlchemy 2.0+ (ORM)
- Alembic (Database Migrations)
- Pydantic 2.0+ (Data Validation)
- Python 3.11+

Database:
- PostgreSQL 15+ (Primary Database)
- Redis 7+ (Caching & Sessions)

Authentication:
- python-jose (JWT)
- passlib + bcrypt (Password Hashing)
- python-multipart (File Uploads)

Storage:
- MinIO (S3-compatible Object Storage)
- Ø£Ùˆ AWS S3 (Ù„Ù„Ø¥Ù†ØªØ§Ø¬)

Monitoring:
- Prometheus + Grafana (Metrics)
- Sentry (Error Tracking)
\`\`\`

### Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø«Ø§Ù†ÙŠ: Node.js + Express (Ø¨Ø¯ÙŠÙ„)

\`\`\`
Backend:
- Node.js 20+ LTS
- Express.js 4.18+
- Prisma ORM
- TypeScript 5+

Database:
- PostgreSQL 15+
- Redis 7+

Authentication:
- jsonwebtoken
- bcrypt
- passport.js
\`\`\`

**Ø³Ø£Ø±ÙƒØ² Ø¹Ù„Ù‰ FastAPI Ù„Ø£Ù†Ù‡ Ø§Ù„Ø£ÙØ¶Ù„ Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹.**

---

## ğŸ“ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹

\`\`\`
audit-orbit-backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                 # Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
â”‚   â”œâ”€â”€ config.py               # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
â”‚   â”œâ”€â”€ database.py             # Ø¥Ø¹Ø¯Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
â”‚   â”‚
â”‚   â”œâ”€â”€ models/                 # Ù†Ù…Ø§Ø°Ø¬ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py
â”‚   â”‚   â”œâ”€â”€ annual_plan.py
â”‚   â”‚   â”œâ”€â”€ engagement.py
â”‚   â”‚   â”œâ”€â”€ evidence.py
â”‚   â”‚   â”œâ”€â”€ finding.py
â”‚   â”‚   â”œâ”€â”€ report.py
â”‚   â”‚   â”œâ”€â”€ working_paper.py
â”‚   â”‚   â”œâ”€â”€ sample.py
â”‚   â”‚   â”œâ”€â”€ follow_up.py
â”‚   â”‚   â”œâ”€â”€ management_response.py
â”‚   â”‚   â”œâ”€â”€ checklist.py
â”‚   â”‚   â””â”€â”€ audit_log.py
â”‚   â”‚
â”‚   â”œâ”€â”€ schemas/                # Pydantic Schemas
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py
â”‚   â”‚   â”œâ”€â”€ annual_plan.py
â”‚   â”‚   â”œâ”€â”€ engagement.py
â”‚   â”‚   â”œâ”€â”€ evidence.py
â”‚   â”‚   â”œâ”€â”€ finding.py
â”‚   â”‚   â”œâ”€â”€ report.py
â”‚   â”‚   â”œâ”€â”€ common.py           # PageResponse, etc.
â”‚   â”‚   â””â”€â”€ auth.py
â”‚   â”‚
â”‚   â”œâ”€â”€ api/                    # API Routes
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ deps.py             # Dependencies (auth, db)
â”‚   â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.py
â”‚   â”‚   â”‚   â”œâ”€â”€ users.py
â”‚   â”‚   â”‚   â”œâ”€â”€ annual_plans.py
â”‚   â”‚   â”‚   â”œâ”€â”€ engagements.py
â”‚   â”‚   â”‚   â”œâ”€â”€ evidence.py
â”‚   â”‚   â”‚   â”œâ”€â”€ findings.py
â”‚   â”‚   â”‚   â”œâ”€â”€ reports.py
â”‚   â”‚   â”‚   â”œâ”€â”€ working_papers.py
â”‚   â”‚   â”‚   â”œâ”€â”€ samples.py
â”‚   â”‚   â”‚   â”œâ”€â”€ follow_ups.py
â”‚   â”‚   â”‚   â”œâ”€â”€ management_responses.py
â”‚   â”‚   â”‚   â”œâ”€â”€ checklists.py
â”‚   â”‚   â”‚   â””â”€â”€ files.py
â”‚   â”‚   â””â”€â”€ router.py
â”‚   â”‚
â”‚   â”œâ”€â”€ core/                   # Core Functionality
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ security.py         # JWT, Password Hashing
â”‚   â”‚   â”œâ”€â”€ permissions.py      # RBAC
â”‚   â”‚   â””â”€â”€ exceptions.py       # Custom Exceptions
â”‚   â”‚
â”‚   â”œâ”€â”€ services/               # Business Logic
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth_service.py
â”‚   â”‚   â”œâ”€â”€ user_service.py
â”‚   â”‚   â”œâ”€â”€ annual_plan_service.py
â”‚   â”‚   â”œâ”€â”€ engagement_service.py
â”‚   â”‚   â”œâ”€â”€ evidence_service.py
â”‚   â”‚   â”œâ”€â”€ file_service.py
â”‚   â”‚   â””â”€â”€ notification_service.py
â”‚   â”‚
â”‚   â””â”€â”€ utils/                  # Utilities
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ email.py
â”‚       â”œâ”€â”€ validators.py
â”‚       â””â”€â”€ helpers.py
â”‚
â”œâ”€â”€ alembic/                    # Database Migrations
â”‚   â”œâ”€â”€ versions/
â”‚   â””â”€â”€ env.py
â”‚
â”œâ”€â”€ tests/                      # Tests
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py
â”‚   â”œâ”€â”€ test_auth.py
â”‚   â”œâ”€â”€ test_users.py
â”‚   â””â”€â”€ test_engagements.py
â”‚
â”œâ”€â”€ scripts/                    # Utility Scripts
â”‚   â”œâ”€â”€ init_db.py
â”‚   â”œâ”€â”€ seed_data.py
â”‚   â””â”€â”€ create_admin.py
â”‚
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ alembic.ini
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ docker-compose.yml
â””â”€â”€ README.md
\`\`\`

---

## ğŸ—„ï¸ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

### Schema Ø§Ù„ÙƒØ§Ù…Ù„

\`\`\`sql
-- ============================================
-- 1. USERS & AUTHENTICATION
-- ============================================

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    hashed_password VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    locale VARCHAR(10) DEFAULT 'ar',
    tz VARCHAR(50) DEFAULT 'Asia/Riyadh',
    active BOOLEAN DEFAULT true,
    email_verified BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP,
    CONSTRAINT email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$')
);

CREATE TABLE roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    resource VARCHAR(50) NOT NULL,
    action VARCHAR(50) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE user_roles (
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, role_id)
);

CREATE TABLE role_permissions (
    role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
    permission_id UUID REFERENCES permissions(id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, permission_id)
);

CREATE TABLE refresh_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token VARCHAR(500) UNIQUE NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    revoked BOOLEAN DEFAULT false
);

-- ============================================
-- 2. ANNUAL PLANS
-- ============================================

CREATE TABLE annual_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    year INTEGER NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    status VARCHAR(20) DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT status_check CHECK (status IN ('draft', 'approved', 'active', 'closed')),
    CONSTRAINT year_check CHECK (year >= 2000 AND year <= 2100)
);

-- ============================================
-- 3. ENGAGEMENTS
-- ============================================

CREATE TABLE engagements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    annual_plan_id UUID REFERENCES annual_plans(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    status VARCHAR(20) DEFAULT 'planning',
    start_date DATE,
    end_date DATE,
    lead_auditor_id UUID REFERENCES users(id),
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT status_check CHECK (status IN ('planning', 'fieldwork', 'reporting', 'completed', 'cancelled')),
    CONSTRAINT date_check CHECK (end_date IS NULL OR end_date >= start_date)
);

CREATE TABLE engagement_team (
    engagement_id UUID REFERENCES engagements(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (engagement_id, user_id)
);

-- ============================================
-- 4. CHECKLISTS
-- ============================================

CREATE TABLE checklists (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE checklist_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    checklist_id UUID REFERENCES checklists(id) ON DELETE CASCADE,
    text TEXT NOT NULL,
    order_num INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE engagement_checklists (
    engagement_id UUID REFERENCES engagements(id) ON DELETE CASCADE,
    checklist_id UUID REFERENCES checklists(id) ON DELETE CASCADE,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (engagement_id, checklist_id)
);

CREATE TABLE checklist_responses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    engagement_id UUID REFERENCES engagements(id) ON DELETE CASCADE,
    checklist_item_id UUID REFERENCES checklist_items(id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'pending',
    notes TEXT,
    completed_by UUID REFERENCES users(id),
    completed_at TIMESTAMP,
    CONSTRAINT status_check CHECK (status IN ('pending', 'completed', 'not_applicable'))
);

-- ============================================
-- 5. EVIDENCE
-- ============================================

CREATE TABLE evidence (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    engagement_id UUID REFERENCES engagements(id) ON DELETE CASCADE,
    filename VARCHAR(255) NOT NULL,
    original_filename VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    size_bytes BIGINT NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    uploaded_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT status_check CHECK (status IN ('pending', 'ready', 'failed'))
);

-- ============================================
-- 6. FINDINGS
-- ============================================

CREATE TABLE findings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    evidence_id UUID REFERENCES evidence(id) ON DELETE SET NULL,
    engagement_id UUID REFERENCES engagements(id) ON DELETE CASCADE,
    scenario_id VARCHAR(100),
    title VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    severity VARCHAR(20) NOT NULL,
    status VARCHAR(20) DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT severity_check CHECK (severity IN ('low', 'medium', 'high', 'critical')),
    CONSTRAINT status_check CHECK (status IN ('draft', 'review', 'approved'))
);

-- ============================================
-- 7. MANAGEMENT RESPONSES
-- ============================================

CREATE TABLE management_responses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    finding_id UUID REFERENCES findings(id) ON DELETE CASCADE,
    response_text TEXT NOT NULL,
    action_plan TEXT,
    responsible_person VARCHAR(255),
    target_date DATE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- 8. FOLLOW-UPS
-- ============================================

CREATE TABLE follow_ups (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    finding_id UUID REFERENCES findings(id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'pending',
    due_date DATE NOT NULL,
    notes TEXT,
    assigned_to UUID REFERENCES users(id),
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT status_check CHECK (status IN ('pending', 'in_progress', 'completed', 'overdue'))
);

-- ============================================
-- 9. REPORTS
-- ============================================

CREATE TABLE reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    engagement_id UUID REFERENCES engagements(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    status VARCHAR(20) DEFAULT 'draft',
    content TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    published_at TIMESTAMP,
    CONSTRAINT status_check CHECK (status IN ('draft', 'submitted', 'approved', 'published'))
);

-- ============================================
-- 10. WORKING PAPERS
-- ============================================

CREATE TABLE working_papers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    engagement_id UUID REFERENCES engagements(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    content TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- 11. SAMPLES
-- ============================================

CREATE TABLE samples (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    engagement_id UUID REFERENCES engagements(id) ON DELETE CASCADE,
    description TEXT NOT NULL,
    size INTEGER NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT status_check CHECK (status IN ('pending', 'tested', 'passed', 'failed'))
);

-- ============================================
-- 12. AUDIT LOGS
-- ============================================

CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(50) NOT NULL,
    resource_id UUID,
    details JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================
-- INDEXES FOR PERFORMANCE
-- ============================================

-- Users
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_active ON users(active);

-- Annual Plans
CREATE INDEX idx_annual_plans_year ON annual_plans(year);
CREATE INDEX idx_annual_plans_status ON annual_plans(status);

-- Engagements
CREATE INDEX idx_engagements_annual_plan ON engagements(annual_plan_id);
CREATE INDEX idx_engagements_status ON engagements(status);
CREATE INDEX idx_engagements_dates ON engagements(start_date, end_date);

-- Evidence
CREATE INDEX idx_evidence_engagement ON evidence(engagement_id);
CREATE INDEX idx_evidence_status ON evidence(status);

-- Findings
CREATE INDEX idx_findings_engagement ON findings(engagement_id);
CREATE INDEX idx_findings_severity ON findings(severity);
CREATE INDEX idx_findings_status ON findings(status);

-- Audit Logs
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id);
CREATE INDEX idx_audit_logs_created ON audit_logs(created_at DESC);

-- ============================================
-- TRIGGERS FOR UPDATED_AT
-- ============================================

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_annual_plans_updated_at BEFORE UPDATE ON annual_plans
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_engagements_updated_at BEFORE UPDATE ON engagements
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_findings_updated_at BEFORE UPDATE ON findings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_reports_updated_at BEFORE UPDATE ON reports
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_working_papers_updated_at BEFORE UPDATE ON working_papers
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_samples_updated_at BEFORE UPDATE ON samples
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_follow_ups_updated_at BEFORE UPDATE ON follow_ups
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_management_responses_updated_at BEFORE UPDATE ON management_responses
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\`\`\`

---

## ğŸ” Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø© ÙˆØ§Ù„ØªÙÙˆÙŠØ¶

### 1. JWT Authentication

\`\`\`python
# app/core/security.py

from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from app.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire, "type": "access"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def create_refresh_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def decode_token(token: str) -> dict:
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        return payload
    except JWTError:
        return None
\`\`\`

### 2. RBAC (Role-Based Access Control)

\`\`\`python
# app/core/permissions.py

from enum import Enum
from typing import List
from fastapi import HTTPException, status

class Permission(str, Enum):
    # Users
    USER_READ = "user:read"
    USER_CREATE = "user:create"
    USER_UPDATE = "user:update"
    USER_DELETE = "user:delete"
    
    # Annual Plans
    PLAN_READ = "plan:read"
    PLAN_CREATE = "plan:create"
    PLAN_UPDATE = "plan:update"
    PLAN_DELETE = "plan:delete"
    
    # Engagements
    ENGAGEMENT_READ = "engagement:read"
    ENGAGEMENT_CREATE = "engagement:create"
    ENGAGEMENT_UPDATE = "engagement:update"
    ENGAGEMENT_DELETE = "engagement:delete"
    
    # Evidence
    EVIDENCE_READ = "evidence:read"
    EVIDENCE_UPLOAD = "evidence:upload"
    EVIDENCE_DELETE = "evidence:delete"
    
    # Findings
    FINDING_READ = "finding:read"
    FINDING_CREATE = "finding:create"
    FINDING_UPDATE = "finding:update"
    FINDING_DELETE = "finding:delete"
    FINDING_APPROVE = "finding:approve"
    
    # Reports
    REPORT_READ = "report:read"
    REPORT_CREATE = "report:create"
    REPORT_UPDATE = "report:update"
    REPORT_PUBLISH = "report:publish"
    
    # Admin
    ADMIN_FULL = "admin:full"

class Role(str, Enum):
    ADMIN = "admin"
    AUDIT_MANAGER = "audit_manager"
    SENIOR_AUDITOR = "senior_auditor"
    AUDITOR = "auditor"
    VIEWER = "viewer"

# Default role permissions
ROLE_PERMISSIONS = {
    Role.ADMIN: [Permission.ADMIN_FULL],  # Full access
    Role.AUDIT_MANAGER: [
        Permission.USER_READ,
        Permission.PLAN_READ, Permission.PLAN_CREATE, Permission.PLAN_UPDATE,
        Permission.ENGAGEMENT_READ, Permission.ENGAGEMENT_CREATE, Permission.ENGAGEMENT_UPDATE,
        Permission.EVIDENCE_READ, Permission.EVIDENCE_UPLOAD,
        Permission.FINDING_READ, Permission.FINDING_CREATE, Permission.FINDING_UPDATE, Permission.FINDING_APPROVE,
        Permission.REPORT_READ, Permission.REPORT_CREATE, Permission.REPORT_UPDATE, Permission.REPORT_PUBLISH,
    ],
    Role.SENIOR_AUDITOR: [
        Permission.PLAN_READ,
        Permission.ENGAGEMENT_READ, Permission.ENGAGEMENT_UPDATE,
        Permission.EVIDENCE_READ, Permission.EVIDENCE_UPLOAD,
        Permission.FINDING_READ, Permission.FINDING_CREATE, Permission.FINDING_UPDATE,
        Permission.REPORT_READ, Permission.REPORT_CREATE, Permission.REPORT_UPDATE,
    ],
    Role.AUDITOR: [
        Permission.PLAN_READ,
        Permission.ENGAGEMENT_READ,
        Permission.EVIDENCE_READ, Permission.EVIDENCE_UPLOAD,
        Permission.FINDING_READ, Permission.FINDING_CREATE,
        Permission.REPORT_READ,
    ],
    Role.VIEWER: [
        Permission.PLAN_READ,
        Permission.ENGAGEMENT_READ,
        Permission.EVIDENCE_READ,
        Permission.FINDING_READ,
        Permission.REPORT_READ,
    ],
}

def check_permission(user_permissions: List[str], required_permission: Permission) -> bool:
    """Check if user has required permission"""
    if Permission.ADMIN_FULL in user_permissions:
        return True
    return required_permission in user_permissions

def require_permission(required_permission: Permission):
    """Decorator to check permission"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # Get current user from dependency
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Not authenticated"
                )
            
            user_permissions = current_user.get('permissions', [])
            if not check_permission(user_permissions, required_permission):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Insufficient permissions"
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator
\`\`\`

---

## ğŸŒ ÙˆØ§Ø¬Ù‡Ø§Øª Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª (APIs)

### API Structure

\`\`\`
Base URL: https://api.auditOrbit.com/api/v1

Authentication: Bearer Token (JWT)
Content-Type: application/json
\`\`\`

### 1. Authentication APIs

\`\`\`python
# app/api/v1/auth.py

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.api.deps import get_db
from app.schemas.auth import TokenResponse, LoginRequest
from app.services.auth_service import AuthService

router = APIRouter(prefix="/auth", tags=["Authentication"])

@router.post("/login", response_model=TokenResponse)
async def login(
    credentials: LoginRequest,
    db: Session = Depends(get_db)
):
    """
    Login endpoint
    
    Returns:
    - access_token: JWT access token (expires in 30 minutes)
    - refresh_token: JWT refresh token (expires in 7 days)
    - token_type: "bearer"
    - user: User object
    """
    auth_service = AuthService(db)
    result = await auth_service.login(credentials.email, credentials.password)
    
    if not result:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password"
        )
    
    return result

@router.post("/refresh", response_model=TokenResponse)
async def refresh_token(
    refresh_token: str,
    db: Session = Depends(get_db)
):
    """Refresh access token using refresh token"""
    auth_service = AuthService(db)
    result = await auth_service.refresh_token(refresh_token)
    
    if not result:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired refresh token"
        )
    
    return result

@router.post("/logout")
async def logout(
    refresh_token: str,
    db: Session = Depends(get_db)
):
    """Logout and revoke refresh token"""
    auth_service = AuthService(db)
    await auth_service.logout(refresh_token)
    return {"message": "Successfully logged out"}

@router.post("/change-password")
async def change_password(
    old_password: str,
    new_password: str,
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Change user password"""
    auth_service = AuthService(db)
    success = await auth_service.change_password(
        current_user['id'],
        old_password,
        new_password
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Incorrect old password"
        )
    
    return {"message": "Password changed successfully"}
\`\`\`

### 2. Users APIs

\`\`\`python
# app/api/v1/users.py

from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List
from app.api.deps import get_db, get_current_user
from app.schemas.user import UserResponse, UserCreate, UserUpdate
from app.schemas.common import PageResponse
from app.services.user_service import UserService
from app.core.permissions import Permission, require_permission

router = APIRouter(prefix="/users", tags=["Users"])

@router.get("", response_model=PageResponse[UserResponse])
@require_permission(Permission.USER_READ)
async def list_users(
    page: int = Query(1, ge=1),
    size: int = Query(20, ge=1, le=100),
    search: str = Query(None),
    active: bool = Query(None),
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """List all users with pagination and filters"""
    user_service = UserService(db)
    return await user_service.list_users(page, size, search, active)

@router.get("/{user_id}", response_model=UserResponse)
@require_permission(Permission.USER_READ)
async def get_user(
    user_id: str,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Get user by ID"""
    user_service = UserService(db)
    user = await user_service.get_user(user_id)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

@router.post("", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
@require_permission(Permission.USER_CREATE)
async def create_user(
    user_data: UserCreate,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Create new user"""
    user_service = UserService(db)
    return await user_service.create_user(user_data)

@router.put("/{user_id}", response_model=UserResponse)
@require_permission(Permission.USER_UPDATE)
async def update_user(
    user_id: str,
    user_data: UserUpdate,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Update user"""
    user_service = UserService(db)
    user = await user_service.update_user(user_id, user_data)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

@router.delete("/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
@require_permission(Permission.USER_DELETE)
async def delete_user(
    user_id: str,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Delete user"""
    user_service = UserService(db)
    success = await user_service.delete_user(user_id)
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return None
\`\`\`

### 3. Annual Plans APIs

\`\`\`python
# app/api/v1/annual_plans.py

from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from app.api.deps import get_db, get_current_user
from app.schemas.annual_plan import AnnualPlanResponse, AnnualPlanCreate, AnnualPlanUpdate
from app.schemas.common import PageResponse
from app.services.annual_plan_service import AnnualPlanService
from app.core.permissions import Permission, require_permission

router = APIRouter(prefix="/annual-plans", tags=["Annual Plans"])

@router.get("", response_model=PageResponse[AnnualPlanResponse])
@require_permission(Permission.PLAN_READ)
async def list_annual_plans(
    page: int = Query(1, ge=1),
    size: int = Query(20, ge=1, le=100),
    year: int = Query(None),
    status: str = Query(None),
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """List annual plans with pagination"""
    service = AnnualPlanService(db)
    return await service.list_plans(page, size, year, status)

@router.get("/{plan_id}", response_model=AnnualPlanResponse)
@require_permission(Permission.PLAN_READ)
async def get_annual_plan(
    plan_id: str,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Get annual plan by ID"""
    service = AnnualPlanService(db)
    plan = await service.get_plan(plan_id)
    
    if not plan:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Annual plan not found"
        )
    
    return plan

@router.post("", response_model=AnnualPlanResponse, status_code=status.HTTP_201_CREATED)
@require_permission(Permission.PLAN_CREATE)
async def create_annual_plan(
    plan_data: AnnualPlanCreate,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Create new annual plan"""
    service = AnnualPlanService(db)
    return await service.create_plan(plan_data, current_user['id'])

@router.put("/{plan_id}", response_model=AnnualPlanResponse)
@require_permission(Permission.PLAN_UPDATE)
async def update_annual_plan(
    plan_id: str,
    plan_data: AnnualPlanUpdate,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Update annual plan"""
    service = AnnualPlanService(db)
    plan = await service.update_plan(plan_id, plan_data)
    
    if not plan:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Annual plan not found"
        )
    
    return plan

@router.delete("/{plan_id}", status_code=status.HTTP_204_NO_CONTENT)
@require_permission(Permission.PLAN_DELETE)
async def delete_annual_plan(
    plan_id: str,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Delete annual plan"""
    service = AnnualPlanService(db)
    success = await service.delete_plan(plan_id)
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Annual plan not found"
        )
    
    return None
\`\`\`

### 4. File Upload API

\`\`\`python
# app/api/v1/files.py

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File
from sqlalchemy.orm import Session
from app.api.deps import get_db, get_current_user
from app.services.file_service import FileService
from app.core.permissions import Permission, require_permission

router = APIRouter(prefix="/files", tags=["Files"])

@router.post("/upload")
@require_permission(Permission.EVIDENCE_UPLOAD)
async def upload_file(
    engagement_id: str,
    file: UploadFile = File(...),
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Upload evidence file"""
    file_service = FileService(db)
    
    # Validate file size (max 100MB)
    if file.size > 100 * 1024 * 1024:
        raise HTTPException(
            status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,
            detail="File size exceeds 100MB limit"
        )
    
    result = await file_service.upload_evidence(
        engagement_id,
        file,
        current_user['id']
    )
    
    return result

@router.get("/download/{evidence_id}")
@require_permission(Permission.EVIDENCE_READ)
async def download_file(
    evidence_id: str,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Download evidence file"""
    file_service = FileService(db)
    file_url = await file_service.get_download_url(evidence_id)
    
    if not file_url:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="File not found"
        )
    
    return {"download_url": file_url}

@router.delete("/{evidence_id}", status_code=status.HTTP_204_NO_CONTENT)
@require_permission(Permission.EVIDENCE_DELETE)
async def delete_file(
    evidence_id: str,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Delete evidence file"""
    file_service = FileService(db)
    success = await file_service.delete_evidence(evidence_id)
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="File not found"
        )
    
    return None
\`\`\`

---

## ğŸ“¦ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù„ÙØ§Øª

### MinIO Configuration

\`\`\`python
# app/services/file_service.py

from minio import Minio
from minio.error import S3Error
from app.config import settings
import uuid
from datetime import timedelta

class FileService:
    def __init__(self, db):
        self.db = db
        self.minio_client = Minio(
            settings.MINIO_ENDPOINT,
            access_key=settings.MINIO_ACCESS_KEY,
            secret_key=settings.MINIO_SECRET_KEY,
            secure=settings.MINIO_SECURE
        )
        self.bucket_name = settings.MINIO_BUCKET_NAME
        
        # Create bucket if not exists
        if not self.minio_client.bucket_exists(self.bucket_name):
            self.minio_client.make_bucket(self.bucket_name)
    
    async def upload_evidence(self, engagement_id: str, file: UploadFile, user_id: str):
        """Upload evidence file to MinIO"""
        try:
            # Generate unique filename
            file_extension = file.filename.split('.')[-1]
            unique_filename = f"{uuid.uuid4()}.{file_extension}"
            object_name = f"evidence/{engagement_id}/{unique_filename}"
            
            # Upload to MinIO
            self.minio_client.put_object(
                self.bucket_name,
                object_name,
                file.file,
                length=file.size,
                content_type=file.content_type
            )
            
            # Save to database
            evidence = Evidence(
                engagement_id=engagement_id,
                filename=unique_filename,
                original_filename=file.filename,
                file_path=object_name,
                size_bytes=file.size,
                mime_type=file.content_type,
                status="ready",
                uploaded_by=user_id
            )
            self.db.add(evidence)
            self.db.commit()
            self.db.refresh(evidence)
            
            return evidence
            
        except S3Error as e:
            raise Exception(f"Failed to upload file: {str(e)}")
    
    async def get_download_url(self, evidence_id: str):
        """Generate presigned URL for file download"""
        evidence = self.db.query(Evidence).filter(Evidence.id == evidence_id).first()
        if not evidence:
            return None
        
        try:
            url = self.minio_client.presigned_get_object(
                self.bucket_name,
                evidence.file_path,
                expires=timedelta(hours=1)
            )
            return url
        except S3Error:
            return None
    
    async def delete_evidence(self, evidence_id: str):
        """Delete evidence file"""
        evidence = self.db.query(Evidence).filter(Evidence.id == evidence_id).first()
        if not evidence:
            return False
        
        try:
            # Delete from MinIO
            self.minio_client.remove_object(self.bucket_name, evidence.file_path)
            
            # Delete from database
            self.db.delete(evidence)
            self.db.commit()
            
            return True
        except S3Error:
            return False
\`\`\`

---

## ğŸ”’ Ø§Ù„Ø£Ù…Ø§Ù†

### Security Best Practices

\`\`\`python
# app/main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

app = FastAPI(
    title="AuditOrbit API",
    description="Internal Audit Management System API",
    version="1.0.0",
    docs_url="/api/docs",
    redoc_url="/api/redoc"
)

# Rate Limiting
limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Trusted Host
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=settings.ALLOWED_HOSTS
)

# GZip Compression
app.add_middleware(GZipMiddleware, minimum_size=1000)

# Security Headers
@app.middleware("http")
async def add_security_headers(request, call_next):
    response = await call_next(request)
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    return response
\`\`\`

---

## ğŸš€ Ø§Ù„ØªØ«Ø¨ÙŠØª ÙˆØ§Ù„Ø¥Ø¹Ø¯Ø§Ø¯

### 1. Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…

\`\`\`
- Python 3.11+
- PostgreSQL 15+
- Redis 7+
- MinIO (Ø£Ùˆ AWS S3)
- Docker & Docker Compose (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
\`\`\`

### 2. Ø§Ù„ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…Ø­Ù„ÙŠ

\`\`\`bash
# 1. Clone the repository
git clone https://github.com/your-org/audit-orbit-backend.git
cd audit-orbit-backend

# 2. Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# 3. Install dependencies
pip install -r requirements.txt

# 4. Copy environment file
cp .env.example .env

# 5. Edit .env with your configuration
nano .env

# 6. Run database migrations
alembic upgrade head

# 7. Create initial admin user
python scripts/create_admin.py

# 8. Run the server
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
\`\`\`

### 3. Ù…Ù„Ù .env

\`\`\`env
# Application
APP_NAME=AuditOrbit
APP_ENV=development
DEBUG=true
SECRET_KEY=your-super-secret-key-change-this-in-production
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

# Database
DATABASE_URL=postgresql://postgres:password@localhost:5432/auditOrbit
DATABASE_POOL_SIZE=20
DATABASE_MAX_OVERFLOW=0

# Redis
REDIS_URL=redis://localhost:6379/0

# MinIO / S3
MINIO_ENDPOINT=localhost:9000
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
MINIO_BUCKET_NAME=audit-evidence
MINIO_SECURE=false

# CORS
ALLOWED_ORIGINS=http://localhost:3000,https://yourdomain.com
ALLOWED_HOSTS=localhost,yourdomain.com

# Email (Optional)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASSWORD=your-app-password
SMTP_FROM=noreply@auditOrbit.com

# Sentry (Optional)
SENTRY_DSN=your-sentry-dsn
\`\`\`

### 4. Docker Compose

\`\`\`yaml
# docker-compose.yml

version: '3.8'

services:
  # PostgreSQL Database
  postgres:
    image: postgres:15-alpine
    container_name: auditOrbit-db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: auditOrbit
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis Cache
  redis:
    image: redis:7-alpine
    container_name: auditOrbit-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # MinIO Object Storage
  minio:
    image: minio/minio:latest
    container_name: auditOrbit-minio
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

  # FastAPI Backend
  backend:
    build: .
    container_name: auditOrbit-backend
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    environment:
      DATABASE_URL: postgresql://postgres:password@postgres:5432/auditOrbit
      REDIS_URL: redis://redis:6379/0
      MINIO_ENDPOINT: minio:9000
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: minioadmin
    ports:
      - "8000:8000"
    volumes:
      - .:/app
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy

volumes:
  postgres_data:
  redis_data:
  minio_data:
\`\`\`

### 5. ØªØ´ØºÙŠÙ„ Docker

\`\`\`bash
# Start all services
docker-compose up -d

# View logs
docker-compose logs -f backend

# Stop all services
docker-compose down

# Stop and remove volumes
docker-compose down -v
\`\`\`

---

## ğŸŒ Ø§Ù„Ù†Ø´Ø± (Deployment)

### Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù†Ø´Ø± Ø§Ù„Ù…ÙˆØµÙ‰ Ø¨Ù‡Ø§:

#### 1. Vercel (Ù„Ù„Ù€ Frontend ÙÙ‚Ø·)
- Next.js ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Vercel
- Backend Ù…Ù†ÙØµÙ„

#### 2. Railway.app (Ù…ÙˆØµÙ‰ Ø¨Ù‡ Ù„Ù„Ù€ Backend)
\`\`\`bash
# Install Railway CLI
npm install -g @railway/cli

# Login
railway login

# Initialize project
railway init

# Deploy
railway up
\`\`\`

#### 3. Render.com
- Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù€ PostgreSQL, Redis
- Ù†Ø´Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ù† GitHub
- SSL Ù…Ø¬Ø§Ù†ÙŠ

#### 4. AWS / DigitalOcean
\`\`\`bash
# Using Docker on VPS
ssh user@your-server

# Install Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh

# Clone and deploy
git clone your-repo
cd audit-orbit-backend
docker-compose -f docker-compose.prod.yml up -d
\`\`\`

### Production Checklist

\`\`\`
âœ… ØªØºÙŠÙŠØ± SECRET_KEY Ø¥Ù„Ù‰ Ù‚ÙŠÙ…Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù‚ÙˆÙŠØ©
âœ… ØªÙØ¹ÙŠÙ„ HTTPS (SSL/TLS)
âœ… Ø¥Ø¹Ø¯Ø§Ø¯ Firewall
âœ… ØªÙØ¹ÙŠÙ„ Rate Limiting
âœ… Ø¥Ø¹Ø¯Ø§Ø¯ Backup ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
âœ… Ø¥Ø¹Ø¯Ø§Ø¯ Monitoring (Sentry, Prometheus)
âœ… Ø¥Ø¹Ø¯Ø§Ø¯ Logging
âœ… ØªÙØ¹ÙŠÙ„ CORS Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Environment Variables
âœ… Ø¥Ø¹Ø¯Ø§Ø¯ CI/CD Pipeline
\`\`\`

---

## ğŸ“Š Ø§Ù„Ø®Ù„Ø§ØµØ©

Ù‡Ø°Ù‡ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø®Ù„ÙÙŠØ©:

âœ… **Ø´Ø§Ù…Ù„Ø©** - ØªØ¯Ø¹Ù… Ø¬Ù…ÙŠØ¹ Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
âœ… **Ø¢Ù…Ù†Ø©** - JWT, RBAC, Rate Limiting, Security Headers
âœ… **Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙˆØ³Ø¹** - Async, Caching, Database Indexing
âœ… **Ø³Ù‡Ù„Ø© Ø§Ù„ØªØ«Ø¨ÙŠØª** - Docker Compose, Clear Documentation
âœ… **Ø§Ø­ØªØ±Ø§ÙÙŠØ©** - Best Practices, Type Safety, Error Handling
âœ… **Ù…ÙˆØ«Ù‚Ø©** - Swagger UI, ReDoc, Code Comments
âœ… **Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØµÙŠØ§Ù†Ø©** - Clean Architecture, Service Layer, Separation of Concerns

---

## ğŸ“ Ø§Ù„Ø¯Ø¹Ù…

Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ Ø§Ù„ØªØ«Ø¨ÙŠØª Ø£Ùˆ Ø§Ù„ØªØ·ÙˆÙŠØ±:
1. Ø±Ø§Ø¬Ø¹ Ø§Ù„ØªÙˆØ«ÙŠÙ‚ Ø§Ù„ÙƒØ§Ù…Ù„
2. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ù…Ø«Ù„Ø© ÙÙŠ Ù…Ø¬Ù„Ø¯ `examples/`
3. Ø§ÙØªØ­ Issue Ø¹Ù„Ù‰ GitHub
4. ØªÙˆØ§ØµÙ„ Ù…Ø¹ ÙØ±ÙŠÙ‚ Ø§Ù„ØªØ·ÙˆÙŠØ±

---

**ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù‡Ø°Ø§ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø¨ÙˆØ§Ø³Ø·Ø© Ù…Ù‡Ù†Ø¯Ø³ Ø¨Ø±Ù…Ø¬ÙŠØ§Øª Ø¨Ø®Ø¨Ø±Ø© 10 Ø³Ù†ÙˆØ§Øª** ğŸš€
